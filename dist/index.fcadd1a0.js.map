{"mappings":"ICOW,EAAQ,EAAR,EAIR,IAAI,CAJY,EAIT,WAcR,SAAS,EAAc,CAAK,EAC1B,GAAI,CAAC,yBAAyB,IAAI,CAAC,IAAU,CAAC,YAAY,IAAI,CAAC,GAC7D,MAAM,AAAI,MAAM,gBAEpB,CAyCA,IAAI,EAAO,CAAC,EAER,EAAU,SAAiB,CAAO,CAAE,CAAI,CAAE,CAAO,CAAE,CAAO,EAC5D,IAWI,EAXA,EAAW,IAAI,AAEd,CAAA,EAAQ,OAAO,EAAI,AAAkB,aAAlB,OAAO,QAC7B,CAAA,EAAQ,OAAO,CAAG,OAAO,QAAQ,EAAI,OAAO,UAAU,EAAI,IAD5D,EAIA,IAAI,EAAU,EAAQ,OAAO,CAC7B,GAAI,CAAC,EACH,MAAM,AAAI,MAAM,4BAIlB,IAAI,EAAS,CAAC,EACV,EAAc,CAAC,EACf,EAAa,EAAE,CACf,EAAY,EAsBhB,SAAS,EAAU,CAAQ,EACrB,EAAI,MAAM,GACZ,IAEA,EAAI,EAAE,CAAC,OAAQ,EAEnB,CAqDA,SAAS,EAAU,CAAO,CAAE,CAAO,EACjC,EAAQ,WAAW,CAAG,CACxB,CAEA,SAAS,EAAa,CAAO,CAAE,CAAI,CAAE,CAAO,CAAE,CAAQ,EACpD,GAAI,CACF,EAAS,EAAS,EAAM,EAC1B,CAAE,MAAO,EAAK,CAEZ,MADA,EAAU,EAAS,EAAI,OAAO,EACxB,CACR,CACF,CAEA,SAAS,EAAU,CAAO,CAAE,CAAI,CAAE,CAAO,CAAE,CAAQ,EACjD,GAAI,AAAgB,UAAhB,OAAO,EACT,KAxF2B,EACzB,EADyB,EAwFJ,SAAU,CAAO,EACtC,EAAa,EAAS,EAAS,EAAS,EAC1C,EAxFF,CADI,EAAM,IAAI,gBACV,IAAI,CAAC,MAsFU,EAtFE,CAAA,GACrB,EAAI,gBAAgB,CAAC,eAAgB,oBACrC,EAAI,MAAM,CAAG,WACP,AAAe,MAAf,EAAI,MAAM,CACZ,EAAQ,KAAK,KAAK,CAAC,EAAI,YAAY,GAEnC,EAgFM,EAhFa,EAAI,UAAU,CAErC,EACA,EAAI,IAAI,EA+EN,KACS,AAAgB,YAAhB,OAAO,EAChB,EAAK,SAAU,CAAO,EACpB,EAAa,EAAS,EAAS,EAAS,EAC1C,EAAG,SAAU,CAAO,EAClB,EAAU,EAAS,EACrB,GAEA,EAAa,EAAS,EAAM,EAAS,EAEzC,CAEA,SAAS,EAAU,CAAO,CAAE,CAAI,CAAE,CAAO,MAuiBlB,EAAA,EAtiBP,WACR,EAAQ,KAAK,GACf,EAAa,EAAM,EAAQ,KAAK,EAChC,EAAI,SAAS,CAAC,UAAU,OAAO,CAAC,EAAsB,KAExD,EAAI,SAAS,CAAC,WAAW,OAAO,CAAC,EAAgB,EAAM,GACzD,EAiiBI,EACF,IAEA,EAAiB,IAAI,CAAC,EAniB1B,CAlHI,AAFJ,CAAA,EAAU,AA7EZ,SAAoB,CAAO,EACzB,GAAI,AAAmB,UAAnB,OAAO,EAAsB,CAC/B,IAAI,EAAY,EAEhB,GAAI,CADJ,CAAA,EAAU,SAAS,cAAc,CAAC,EAAlC,EAEE,MAAM,AAAI,MAAM,sBAAwB,EAE5C,CACA,OAAO,CACT,EAoEuB,EAArB,EAEY,EAAE,EACZ,CAAA,CAAI,CAAC,EAAQ,EAAE,CAAC,CAAG,IAAI,AAAJ,EAoHrB,IAAI,EAAY,IAAI,OAAO,GAAG,CAE9B,SAAS,EAAgB,CAAI,CAAE,CAAO,EAMpC,IAAK,IALD,EAAU,CACZ,KAAM,oBACN,SAAU,EAAE,AACd,EAES,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACpC,IAAI,EAAM,CAAI,CAAC,EAAE,CACb,EAAa,OAAO,MAAM,CAAC,CAAC,EAAG,GAC/B,EAAY,KAAK,EAErB,GAAI,AAAY,UAAZ,EAAqB,CAQvB,GAPK,EAAW,IAAI,EAClB,CAAA,EAAW,IAAI,CAAG,EAAQ,WAAW,EAAI,SAD3C,EAGA,EAAW,eAAe,CAAG,AAAoB,YAApB,EAAW,IAAI,CAAiB,GAAM,EACnE,EAAW,iBAAiB,CAAG,AAAoB,YAApB,EAAW,IAAI,CAAiB,SAAW,SAC1E,EAAW,iBAAiB,CAAG,AAAoB,YAApB,EAAW,IAAI,CAAiB,CAAC,EAAG,GAAG,CAAG,CAAC,EAAG,EAAE,CAE3E,AAAoB,YAApB,EAAW,IAAI,CAAgB,CACjC,IAAI,EAAQ,EAAW,KAAK,EAAI,EAAc,KAAK,EAAI,UAEnD,EAAW,EAAU,GAAG,CAAC,EACZ,MAAA,IAAb,IACF,EAAW,EAAU,IAAI,CACzB,EAAc,GACd,EAAU,GAAG,CAAC,EAAO,IAGvB,EAAW,IAAI,CAAG,WAAa,CACjC,CAEA,IAAI,EAAc,EAAe,GAEjC,GAAI,CAAC,CAAW,CAAC,EAAE,CACjB,MAAM,AAAI,MAAO,4BAA8B,EAAI,KAGrD,GAAI,CAAC,CAAW,CAAC,EAAE,CACjB,MAAM,AAAI,MAAO,6BAA+B,EAAI,KAGtD,EAAW,CACT,KAAM,QACN,YAAa,CACf,CACF,KAAO,CAGL,GAAI,CAFJ,CAAA,EAAW,EAAI,QAAQ,AAAR,EAGb,MAAM,AAAI,MAAO,4BAA8B,EAAI,IAGrD,QAAO,EAAW,QAAQ,CAE1B,EAAW,YAAY,CAAG,EAAW,KAAK,EAAI,EAAc,KAAK,EAAI,SAEvE,CAEA,EAAQ,QAAQ,CAAC,IAAI,CAAC,CACpB,KAAM,UACN,GAAI,EACJ,SAAU,EACV,WAAY,CACd,EACF,CAEA,OAAO,CACT,CAEA,SAAS,EAAe,CAAG,EACzB,MAAO,CAAC,EAAI,SAAS,EAAI,EAAI,GAAG,EAAI,EAAI,GAAG,CAAE,EAAI,QAAQ,EAAI,EAAI,GAAG,CAAC,AACvE,CAMA,SAAS,EAAa,CAAI,CAAE,CAAY,EACtC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACpC,IAAI,EAAM,CAAI,CAAC,EAAE,CACb,EANC,AAMoB,EANhB,EAAE,AAON,CAAA,CAAM,CAAC,EAAQ,EAClB,CAAA,CAAM,CAAC,EAAQ,CAAG,EAAE,AAAF,EAEpB,CAAM,CAAC,EAAQ,CAAC,IAAI,CAAC,EAAe,IAChC,GAAgB,EAAa,GAAG,EAAI,CAAM,CAAC,EAAQ,CAAC,MAAM,CAAG,EAAa,GAAG,EAC/E,CAAM,CAAC,EAAQ,CAAC,KAAK,EAEzB,CACF,CAEA,SAAS,EAAsB,CAAI,EAMjC,IAAK,IALD,EAAU,CACZ,KAAM,oBACN,SAAU,EAAE,AACd,EAES,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACpC,IAAI,EAAM,CAAI,CAAC,EAAE,CACjB,EAAQ,QAAQ,CAAC,IAAI,CAAC,CACpB,KAAM,UACN,SAAU,CACR,KAAM,aACN,YAAa,CAAM,CA7BlB,AA6B8B,EA7B1B,EAAE,CA6B6B,AACtC,CACF,EACF,CAEA,OAAO,CACT,CAuRA,SAAS,EAAa,CAAM,CAAE,CAAQ,EACpC,GAAI,AAAkB,UAAlB,EAAS,IAAI,CACf,EAAO,MAAM,CAAC,EAAS,WAAW,OAC7B,GAAI,AAAkB,YAAlB,EAAS,IAAI,CAEtB,IAAK,IADD,EAAc,EAAS,WAAW,CAAC,EAAE,CAChC,EAAI,EAAG,EAAI,EAAY,MAAM,CAAE,IACtC,EAAO,MAAM,CAAC,CAAW,CAAC,EAAE,OAEzB,GAAI,AAAkB,iBAAlB,EAAS,IAAI,CAEtB,IAAK,IADD,EAAgB,EAAS,WAAW,CAC/B,EAAM,EAAG,EAAM,EAAc,MAAM,CAAE,IAE5C,IAAK,IADD,EAAU,CAAa,CAAC,EAAI,CAAC,EAAE,CAC1B,EAAI,EAAG,EAAI,EAAQ,MAAM,CAAE,IAClC,EAAO,MAAM,CAAC,CAAO,CAAC,EAAE,CAIhC,CAEA,IAAI,EAAc,SAAU,CAAO,CAAE,CAAI,CAAE,CAAO,EAChD,IAAI,EAAU,EAAgB,EAAM,GACpC,EAAU,GAAW,CAAC,EAEtB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAQ,QAAQ,CAAC,MAAM,CAAE,IAC3C,EAAa,EAAQ,EAAQ,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAInD,CAAA,EAAQ,WAAW,CAAG,GAEtB,IAAI,EAAQ,EAAQ,KAAK,CACzB,GAAI,CAAC,EAAO,CAEV,GADiB,CAAE,CAAA,gBAAiB,CAAA,GAAY,YAAY,IAAI,CAAC,EAAQ,OAAO,EAE9E,MAAM,AAAI,MAAM,+BAEhB,EAAQ,oCAEZ,CAEA,IAAI,EAAO,EAAQ,IAAI,CACnB,EAAS,EAAQ,MAAM,CACtB,IACE,EAAO,OAAO,IAGjB,EAAS,CAAC,EAAG,EAAE,CACV,GACH,CAAA,EAAO,CAAA,GAJT,EAAS,EAAO,SAAS,IAQxB,GACH,CAAA,EAAO,EADT,EAIA,IAAI,EAAa,CACf,UAAW,EACX,MAAO,EACP,WAAY,CAAA,EACZ,gBAAiB,CAAA,EACjB,OAAQ,EACR,KAAM,CACR,CACK,CAAA,EAAQ,KAAK,EAChB,CAAA,EAAW,UAAU,CAAG,UAD1B,EAGI,EAAQ,WAAW,EACrB,CAAA,EAAW,WAAW,CAAG,EAAQ,WAAW,AAAX,EAE/B,EAAQ,OAAO,EACjB,OAAO,MAAM,CAAC,EAAY,EAAQ,OAAO,EAE3C,EAAM,IAAI,EAAQ,GAAG,CAAC,GAElB,EAAQ,QAAQ,EAClB,EAAI,UAAU,CAAC,IAAI,EAAQ,iBAAiB,CAAC,CAAC,YAAa,CAAA,CAAK,IAG7D,EAAQ,IAAI,GAEV,EAAI,KAAK,CAAC,UAAU,EACvB,CAAA,EAAI,KAAK,CAAC,UAAU,CAAG,CAAC,CAAA,EAIrB,EAAO,OAAO,IAAM,EAAI,OAAO,KAAO,GACzC,EAAI,SAAS,CAAC,EAAQ,CAAC,QAAS,GAAI,QAAS,CAAA,EAAO,QAAS,EAAE,IAInE,EAAS,GAAG,CAAG,EAEf,EAAU,WACJ,EAAQ,KAAK,GACf,EAAa,GAEb,EAAI,SAAS,CAAC,SAAU,CACtB,KAAM,UACN,KAAM,EAAsB,EAAE,CAChC,GAEA,EAAI,QAAQ,CAAC,CACX,GAAI,SACJ,OAAQ,SACR,KAAM,OACN,OAAQ,CACN,YAAa,QACb,WAAY,OACd,EACA,MAAO,CACL,aAAc,OACd,aAAc,CAChB,CACF,IAGF,IAAI,EAAc,EAAU,IAAI,CAEhC,SAAS,QASH,EARJ,GAAI,AAAgB,IAAhB,EAAmB,CACrB,IACA,MACF,CAMA,IAJA,AAjWN,SAAkB,CAAI,CAAE,CAAO,EAC7B,IAAI,EAAc,CAAC,EAOnB,GALA,EAAI,SAAS,CAAC,EAAM,CAClB,KAAM,UACN,KAAM,CACR,GAEI,AAAY,UAAZ,EAIF,EAAI,QAAQ,CAAC,CACX,GAAK,EAAO,QACZ,OAAQ,EACR,KAAM,SACN,OAAQ,CACN,aAAc,UACd,YAAa,GACb,cAAe,MACf,cAAe,CAAC,EAAG,EAAE,AACvB,EACA,MAAO,CACL,kBAAmB,yBACnB,kBAAmB,CACrB,CACF,GACA,EAAI,QAAQ,CAAC,CACX,GAAI,EACJ,OAAQ,EACR,KAAM,SACN,OAAQ,CACN,aAAc,YACd,qBAAsB,CAAA,EACtB,YAAa,CAAC,KAAM,WAAY,SAAU,iBAAiB,EAC3D,cAAe,CAAC,KAAM,WAAY,SAAU,mBAAmB,EAC/D,cAAe,CAAC,KAAM,WAAY,SAAU,mBAAmB,CACjE,CACF,OACK,CACL,IAAI,EAAW,AAvDnB,SAAyB,CAAG,EAI1B,IAAK,IADD,EADA,EAAS,EAAI,QAAQ,GAAG,MAAM,CAEzB,EAAI,EAAO,MAAM,CAAG,EAAG,GAAK,EAAG,IAAK,CAC3C,IAAI,EAAQ,CAAM,CAAC,EAAE,CAErB,GAAI,CAAE,CAAA,EAAM,QAAQ,EAAI,AAA8C,iBAA9C,EAAM,QAAQ,CAAC,0BAA0B,AAAK,EACpE,MAEF,EAAW,EAAM,EAAE,AACrB,CACA,OAAO,CACT,EA0CmC,GAE3B,EAAY,EAAO,WACvB,EAAI,QAAQ,CAAC,CACX,GAAI,EACJ,OAAQ,EACR,KAAM,OACN,MAAO,CACL,aAAc,CAAC,KAAM,WAAY,SAAU,cAAc,EACzD,eAAgB,GAChB,aAAc,CAChB,CACF,EAAG,GAEH,EAAI,QAAQ,CAAC,CACX,GAAI,EACJ,OAAQ,EACR,KAAM,OACN,MAAO,CACL,aAAc,CAAC,KAAM,WAAY,SAAU,cAAc,EACzD,eAAgB,EAClB,CACF,EAAG,GAKH,IAAK,IAHD,EAAY,EAAO,QACnB,EAAY,AAlHpB,SAA8B,CAAI,EAMhC,IAAK,IALD,EAAU,CACZ,KAAM,oBACN,SAAU,EAAE,AACd,EAES,EAAI,EAAG,EAAI,EAAK,QAAQ,CAAC,MAAM,CAAE,IAAK,CAC7C,IAAI,EAAU,EAAK,QAAQ,CAAC,EAAE,CAC1B,EAAe,KAAK,EAGpB,EAAS,IAAI,EAAQ,YAAY,CAErC,GADA,EAAa,EAAQ,EAAQ,QAAQ,EACjC,CAAC,EAAO,OAAO,GAAI,CACrB,IAAI,EAAS,EAAO,SAAS,GAC7B,EAAc,CAAC,EAAO,GAAG,CAAE,EAAO,GAAG,CAAC,AACxC,CAEI,GACF,EAAQ,QAAQ,CAAC,IAAI,CAAC,CACpB,KAAM,UACN,GAAI,EACJ,SAAU,CACR,KAAM,QACN,YAAa,CACf,EACA,WAAY,EAAQ,UAAU,AAChC,EAEJ,CAEA,OAAO,CACT,EAkFyC,GAE5B,EAAI,EAAG,EAAI,EAAU,QAAQ,CAAC,MAAM,CAAE,IAAK,CAClD,IAAI,EAAU,EAAU,QAAQ,CAAC,EAAE,AACnC,CAAA,CAAW,CAAC,EAAQ,EAAE,CAAC,CAAG,EAAQ,QAAQ,CAAC,WAAW,AACxD,CAEA,EAAI,SAAS,CAAC,EAAW,CACvB,KAAM,UACN,KAAM,CACR,GAEA,EAAI,QAAQ,CAAC,CACX,GAAK,EAAO,QACZ,OAAQ,EACR,KAAM,SACN,OAAQ,CACN,aAAc,UACd,YAAa,EACf,EACA,MAAO,CACL,kBAAmB,yBACnB,kBAAmB,CACrB,CACF,EACF,CAEA,IAAI,EAAQ,CAAE,CAAA,UAAW,CAAA,GAAmB,EAAe,KAAK,CAE5D,EAAe,CACjB,YAAa,CAAA,EACb,aAAc,CAAA,CAChB,EACK,GACH,CAAA,EAAa,MAAM,CAAG,QADxB,EAKA,IAAI,EAAQ,IAAI,EAAQ,KAAK,CAAC,GAG1B,EAAS,SAAU,CAAG,CAAE,CAAK,EAE/B,IAAI,EAAS,IAAI,kBAAkB,AADvB,OAAO,gBAAgB,CAAC,EAAM,UAAU,IACX,SAAS,EAG9C,EAAM,EAAO,GAAG,CAChB,EAAO,EAAO,GAAG,CAGjB,CAAA,EANU,GAMO,EANP,CAMc,GAC1B,EAAI,KAAK,CAAC,CAAC,KAAK,GAAG,CAAC,EAPR,EACF,EAMkC,GAAI,KAAK,GAAG,CAAC,EAP7C,EACF,EAMsE,GAAG,CAEvF,EAEI,EAAY,SAAU,CAAC,EACzB,IAsBI,EAtBA,EAAU,EAAgB,GAC1B,EAAU,EAAQ,UAAU,CAAC,OAAO,CAEnC,IAID,AAAY,UAAZ,GAAuB,EAAQ,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,YAC5D,EAAM,OAAO,CAAC,MAAM,CAAG,CACrB,IAAO,CAAC,EAAG,GAAG,CACd,WAAY,CAAC,EAAG,GAAG,CACnB,YAAa,CAAC,EAAG,GAAG,CACpB,OAAU,CAAC,EAAG,IAAI,CAClB,cAAe,CAAC,EAAG,IAAI,CACvB,eAAgB,CAAC,EAAG,IAAI,CACxB,KAAQ,CAAC,GAAI,EAAE,CACf,MAAS,CAAC,IAAK,EAAE,AACnB,EAEA,EAAM,OAAO,CAAC,MAAM,CAAG,GAKvB,EADE,AAAY,UAAZ,EACY,EAAQ,QAAQ,CAAC,WAAW,CAE5B,CAAW,CAAC,EAAQ,EAAE,CAAC,CAIvC,EAAM,SAAS,CAAC,GACZ,EAAe,IAAI,CACrB,EAAM,OAAO,CAAC,GAEd,EAAM,OAAO,CAAC,GAEhB,EAAM,KAAK,CAAC,GAIR,EAAM,UAAU,CAAC,WAAW,CAAG,GAAM,GACvC,CAAA,EAAM,UAAU,CAAC,KAAK,CAAC,KAAK,CAAG,EAAM,UAAU,CAAC,WAAW,CAAG,EAAI,IADpE,EAIgB,SAAZ,GACF,EAAO,EAAK,GAEhB,EAEI,EAAc,SAAU,CAAO,EACjC,OAAO,EAAQ,QAAQ,CAAC,WAAW,CAAC,EAAE,AACxC,EAEI,EAAkB,SAAU,CAAC,EAG/B,IAAK,IAFD,EAAW,EAAE,QAAQ,CACrB,EAAW,CAAQ,CAAC,EAAE,CACjB,EAAI,EAAG,EAAI,EAAS,MAAM,CAAE,IAAK,CACxC,IAAI,EAAU,CAAQ,CAAC,EAAE,CAErB,EAAY,GAAW,EAAY,IACrC,CAAA,EAAW,CADb,CAGF,CACA,OAAO,CACT,EAEA,GAAI,CAAC,EAAO,CACV,IAAI,EAAe,KAEnB,EAAI,EAAE,CAAC,QAAS,EAAM,SAAU,CAAC,EAC/B,IAAI,EAAQ,EAAgB,GAAG,EAAE,CAC7B,IAAU,IACZ,EAAU,GACV,EAAe,EACf,EAAE,kBAAkB,CAAG,CAAA,EAE3B,GAEA,EAAI,EAAE,CAAC,QAAS,SAAU,CAAC,EACpB,EAAE,kBAAkB,GACvB,EAAM,MAAM,GACZ,EAAe,KAEnB,EACF,CAEA,EAAI,EAAE,CAAC,aAAc,EAAM,SAAU,CAAC,EACtB,EAAgB,GAAG,UAAU,CAAC,OAAO,GAGjD,EAAI,SAAS,GAAG,KAAK,CAAC,MAAM,CAAG,UAE3B,GACF,EAAU,GAGhB,GAEA,EAAI,EAAE,CAAC,aAAc,EAAM,WACzB,EAAI,SAAS,GAAG,KAAK,CAAC,MAAM,CAAG,GAE3B,GACF,EAAM,MAAM,EAEhB,EACF,EA+He,UAAW,GAEpB,EAAc,CAAA,EAEN,EAAK,EAAiB,KAAK,IACjC,GAEJ,CAGA,EAAU,OAAO,CAAC,SAAU,CAAE,CAAE,CAAK,EACnC,IAAI,EAAQ,AAjsBpB,SAA2B,CAAO,CAAE,CAAK,EAOvC,IAAI,EAAO,IAAI,EAAQ,MAAM,GAAI,QAAQ,CAAC,aAAa,CAAC,OAGxD,EAAI,eAAe,CAAC,WACpB,EAAI,YAAY,CAAC,QAAS,8BAC1B,EAAI,YAAY,CAAC,SAVJ,IAWb,EAAI,YAAY,CAAC,QAVL,IAWZ,EAAI,YAAY,CAAC,UAAY,aAE7B,EAAc,GAGd,EAAI,aAAa,CAAC,qBAAqB,YAAY,CAAC,OAAQ,GAG5D,IAAI,EAAU,EAAI,gBAAgB,CAAC,UAC/B,EAAS,CAAO,CAAC,EAAQ,MAAM,CAAG,EAAE,CACxC,GAAI,AAAkB,GAAlB,EAAQ,MAAM,CAAO,CAEvB,IAAI,EAAI,EAAO,SAAS,GACxB,EAAE,YAAY,CAAC,OAAQ,WACvB,EAAE,YAAY,CAAC,UAAW,KAC1B,EAAO,UAAU,CAAC,YAAY,CAAC,EAAG,EACpC,CACA,EAAO,YAAY,CAAC,IAAK,KAGzB,IAAI,EAAQ,IAAI,MAAM,GAAe,IAErC,OADA,EAAM,GAAG,CAAG,2BAA8B,mBAAmB,EAAI,SAAS,EACnE,CACT,EA4pBsC,EAAS,GACvC,EAAM,gBAAgB,CAAC,OAAQ,WAC7B,EAAI,QAAQ,CAAE,WAAa,EAAK,MAAQ,GACxC,GACF,EACF,GAEA,GACF,EACF,EAEI,EAAc,CAAA,EACd,EAAmB,EAAE,CAWzB,EAAU,GAAW,CAAC,EAEtB,IAAI,EAAiB,AADrB,CAAA,EAAU,OAAO,MAAM,CAAC,CAAC,EAAG,EAAQ,OAAO,CAAE,EAA7C,EAC6B,QAAQ,EAAI,CAAC,EACtC,EAAgB,EAAQ,OAAO,EAAI,CAAC,EACpC,EAAS,IAAI,EAAQ,YAAY,AAEjC,CAAA,EAAQ,MAAM,CAChB,EAAU,EAAS,EAAM,EAhoB3B,SAA2B,CAAO,CAAE,CAAI,CAAE,CAAO,EAE/C,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,IAAK,CACpC,IAXiB,EAWb,EAAM,CAAI,CAAC,EAAE,CACb,EAXN,AAAI,AAAc,UAAd,OADe,EAYI,EAAI,IAAI,EAVtB,EAEC,IAAI,KAAK,GAAK,OAAO,GAAK,IAS9B,IACG,CAAW,CAAC,EAAG,EAClB,CAAA,CAAW,CAAC,EAAG,CAAG,EAAE,AAAF,EAEpB,CAAW,CAAC,EAAG,CAAC,IAAI,CAAC,GACrB,EAAO,MAAM,CAAC,EAAe,IAEjC,CAEA,IAAK,IAAI,KAAO,EACV,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAa,IACpD,EAAW,IAAI,CAAC,SAAS,IAG7B,EAAW,IAAI,GAGf,EAAY,EAAS,CAAW,CAAC,CAAU,CAAC,EAAU,CAAC,CAAE,GAEzD,EAAU,WACR,WAAW,WACT,AAKN,CAAA,SAAS,EAAU,CAAO,CAAE,CAAO,EAGjC,EAAU,EAAS,CAAW,CAAC,CAAU,GAAC,EAAU,CAAC,CAAE,GAEnD,EAAY,EAAW,MAAM,CAAG,GAClC,WAAW,WACT,EAAU,EAAS,EACrB,EAAG,IAEP,CAAA,EAfgB,EAAS,EACrB,EAAG,IACL,EACF,IAqmBE,EAAU,EAAS,EAAM,EAAS,GAE9B,EAAQ,OAAO,EACjB,CAAA,IAAI,CAAC,UAAU,CAAG,YAAY,WAC5B,EAAU,EAAS,EAAM,EAAS,EACpC,EAAG,AAAkB,IAAlB,EAAQ,OAAO,CAAlB,EAGN,CAEA,CAAA,EAAQ,SAAS,CAAC,YAAY,CAAG,WAC/B,OAAO,IAAI,CAAC,GAAG,AACjB,EAEA,EAAQ,SAAS,CAAC,OAAO,CAAG,WAC1B,IAAI,CAAC,WAAW,GAEZ,IAAI,CAAC,GAAG,GACV,IAAI,CAAC,GAAG,CAAC,MAAM,GACf,IAAI,CAAC,GAAG,CAAG,KAEf,EAEA,EAAQ,SAAS,CAAC,WAAW,CAAG,WAC1B,IAAI,CAAC,UAAU,GACjB,cAAc,IAAI,CAAC,UAAU,EAC7B,IAAI,CAAC,UAAU,CAAG,KAEtB,EA0BA,IAAI,EAAU,CACZ,IAzBQ,WAAW,EAAG,SAAU,CAAO,EACvC,SAAS,EAAI,CAAO,CAAE,CAAI,CAAE,CAAO,EACjC,EAAQ,IAAI,CAAC,IAAI,CAAE,EAAS,EAAM,EAAS,QAC7C,CAMA,OAJK,GAAU,CAAA,EAAI,SAAS,CAAG,CAA/B,EACA,EAAI,SAAS,CAAG,OAAO,MAAM,CAAE,GAAW,EAAQ,SAAS,EAC3D,EAAI,SAAS,CAAC,WAAW,CAAG,EAErB,CACT,EAAE,GAgBA,QAdY,WAAW,EAAG,SAAU,CAAO,EAC3C,SAAS,EAAQ,CAAO,CAAE,CAAI,CAAE,CAAO,EACrC,EAAQ,IAAI,CAAC,IAAI,CAAE,EAAS,EAAM,EAAS,OAC7C,CAMA,OAJK,GAAU,CAAA,EAAQ,SAAS,CAAG,CAAnC,EACA,EAAQ,SAAS,CAAG,OAAO,MAAM,CAAE,GAAW,EAAQ,SAAS,EAC/D,EAAQ,SAAS,CAAC,WAAW,CAAG,EAEzB,CACT,EAAE,GAKA,KAAM,EACN,QAAS,CAAC,EACV,QAAS,IACX,EAgBA,OAdA,EAAQ,GAAG,CAAG,SAAU,CAAO,EAC7B,EAAQ,OAAO,CAAG,CACpB,EAGsB,aAAlB,OAAO,QAA2B,OAAO,OAAO,GAClD,OAAO,OAAO,CAAG,EAGjB,WAAW,WACT,OAAO,aAAa,CAAC,IAAI,MAAM,gBACjC,EAAG,IAGE,CAET,EAt0BE,AAAmB,UAAnB,OAAO,SAAwB,AAAkB,aAAlB,OAAO,OAAyB,OAAO,OAAO,CAAG,IAChF,AAAkB,YAAlB,OAAO,QAAyB,OAAO,GAAG,CAAG,OAAO,GACuB,AAA1E,CAAA,EAAS,AAAsB,aAAtB,OAAO,WAA6B,WAAa,GAAU,IAAA,EAAa,OAAO,CAAG","sources":["<anon>","src/mapkick.js"],"sourcesContent":["/*\r\n * Mapkick.js v0.2.6\r\n * Create beautiful, interactive maps with one line of JavaScript\r\n * https://github.com/ankane/mapkick.js\r\n * MIT License\r\n */ (function(global, factory) {\n    typeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory() : typeof define === \"function\" && define.amd ? define(factory) : (global = typeof globalThis !== \"undefined\" ? globalThis : global || self, global.Mapkick = factory());\n})(this, function() {\n    \"use strict\";\n    function getElement(element) {\n        if (typeof element === \"string\") {\n            var elementId = element;\n            element = document.getElementById(element);\n            if (!element) throw new Error(\"No element with id \" + elementId);\n        }\n        return element;\n    }\n    // check for hex or named color\n    function validateColor(color) {\n        if (!/^#([0-9a-f]{3}){1,2}$/i.test(color) && !/^[a-z]+$/i.test(color)) throw new Error(\"Invalid color\");\n    }\n    function createMarkerImage(library, color) {\n        // set height to center vertically\n        var height = 41;\n        var width = 27;\n        var scale = 2;\n        // get marker svg\n        var svg = new library.Marker()._element.querySelector(\"svg\");\n        // make displayable and center vertically\n        svg.removeAttribute(\"display\");\n        svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        svg.setAttribute(\"height\", height);\n        svg.setAttribute(\"width\", width);\n        svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\n        validateColor(color);\n        // set color\n        svg.querySelector(\"*[fill='#3FB1CE']\").setAttribute(\"fill\", color);\n        // add border to inner circle\n        var circles = svg.querySelectorAll(\"circle\");\n        var circle = circles[circles.length - 1];\n        if (circles.length == 1) {\n            // need to insert new circle for mapbox-gl v2\n            var c = circle.cloneNode();\n            c.setAttribute(\"fill\", \"#000000\");\n            c.setAttribute(\"opacity\", 0.25);\n            circle.parentNode.insertBefore(c, circle);\n        }\n        circle.setAttribute(\"r\", 4.5);\n        // create image\n        var image = new Image(width * scale, height * scale);\n        image.src = \"data:image/svg+xml;utf8,\" + encodeURIComponent(svg.outerHTML);\n        return image;\n    }\n    var maps = {};\n    var BaseMap = function BaseMap(element, data, options, mapType) {\n        var this$1$1 = this;\n        if (!Mapkick.library && typeof window !== \"undefined\") Mapkick.library = window.mapboxgl || window.maplibregl || null;\n        var library = Mapkick.library;\n        if (!library) throw new Error(\"No mapping library found\");\n        var map;\n        var trails = {};\n        var groupedData = {};\n        var timestamps = [];\n        var timeIndex = 0;\n        element = getElement(element);\n        if (element.id) maps[element.id] = this;\n        function getJSON(element, url, success) {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", url, true);\n            xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n            xhr.onload = function() {\n                if (xhr.status === 200) success(JSON.parse(xhr.responseText));\n                else showError(element, xhr.statusText);\n            };\n            xhr.send();\n        }\n        function onMapLoad(callback) {\n            if (map.loaded()) callback();\n            else map.on(\"load\", callback);\n        }\n        function toTimestamp(ts) {\n            if (typeof ts === \"number\") return ts;\n            else return new Date(ts).getTime() / 1000;\n        }\n        function generateReplayMap(element, data, options) {\n            // group data\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var ts = toTimestamp(row.time);\n                if (ts) {\n                    if (!groupedData[ts]) groupedData[ts] = [];\n                    groupedData[ts].push(row);\n                    bounds.extend(rowCoordinates(row));\n                }\n            }\n            for(var i$1 in groupedData)if (Object.prototype.hasOwnProperty.call(groupedData, i$1)) timestamps.push(parseInt(i$1));\n            timestamps.sort();\n            // create map\n            generateMap(element, groupedData[timestamps[timeIndex]], options);\n            onMapLoad(function() {\n                setTimeout(function() {\n                    nextFrame(element, options);\n                }, 100);\n            });\n        }\n        function nextFrame(element, options) {\n            timeIndex++;\n            updateMap(element, groupedData[timestamps[timeIndex]], options);\n            if (timeIndex < timestamps.length - 1) setTimeout(function() {\n                nextFrame(element, options);\n            }, 100);\n        }\n        function showError(element, message) {\n            element.textContent = message;\n        }\n        function errorCatcher(element, data, options, callback) {\n            try {\n                callback(element, data, options);\n            } catch (err) {\n                showError(element, err.message);\n                throw err;\n            }\n        }\n        function fetchData(element, data, options, callback) {\n            if (typeof data === \"string\") getJSON(element, data, function(newData) {\n                errorCatcher(element, newData, options, callback);\n            });\n            else if (typeof data === \"function\") data(function(newData) {\n                errorCatcher(element, newData, options, callback);\n            }, function(message) {\n                showError(element, message);\n            });\n            else errorCatcher(element, data, options, callback);\n        }\n        function updateMap(element, data, options) {\n            onLayersReady(function() {\n                if (options.trail) {\n                    recordTrails(data, options.trail);\n                    map.getSource(\"trails\").setData(generateTrailsGeoJSON(data));\n                }\n                map.getSource(\"objects\").setData(generateGeoJSON(data, options));\n            });\n        }\n        // use Map instead of object for security\n        var markerIds = new window.Map();\n        function generateGeoJSON(data, options) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var properties = Object.assign({}, row);\n                var geometry = void 0;\n                if (mapType === \"point\") {\n                    if (!properties.icon) properties.icon = options.defaultIcon || \"mapkick\";\n                    properties.mapkickIconSize = properties.icon === \"mapkick\" ? 0.5 : 1;\n                    properties.mapkickIconAnchor = properties.icon === \"mapkick\" ? \"bottom\" : \"center\";\n                    properties.mapkickIconOffset = properties.icon === \"mapkick\" ? [\n                        0,\n                        10\n                    ] : [\n                        0,\n                        0\n                    ];\n                    if (properties.icon === \"mapkick\") {\n                        var color = properties.color || markerOptions.color || \"#f84d4d\";\n                        var markerId = markerIds.get(color);\n                        if (markerId === undefined) {\n                            markerId = markerIds.size;\n                            validateColor(color);\n                            markerIds.set(color, markerId);\n                        }\n                        properties.icon = \"mapkick-\" + markerId;\n                    }\n                    var coordinates = rowCoordinates(row);\n                    if (!coordinates[1]) throw new Error(\"missing latitude (index: \" + i + \")\");\n                    if (!coordinates[0]) throw new Error(\"missing longitude (index: \" + i + \")\");\n                    geometry = {\n                        type: \"Point\",\n                        coordinates: coordinates\n                    };\n                } else {\n                    geometry = row.geometry;\n                    if (!geometry) throw new Error(\"missing geometry (index: \" + i + \")\");\n                    delete properties.geometry;\n                    properties.mapkickColor = properties.color || markerOptions.color || \"#0090ff\";\n                }\n                geojson.features.push({\n                    type: \"Feature\",\n                    id: i,\n                    geometry: geometry,\n                    properties: properties\n                });\n            }\n            return geojson;\n        }\n        function rowCoordinates(row) {\n            return [\n                row.longitude || row.lng || row.lon,\n                row.latitude || row.lat\n            ];\n        }\n        function getTrailId(row) {\n            return row.id;\n        }\n        function recordTrails(data, trailOptions) {\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                var trailId = getTrailId(row);\n                if (!trails[trailId]) trails[trailId] = [];\n                trails[trailId].push(rowCoordinates(row));\n                if (trailOptions && trailOptions.len && trails[trailId].length > trailOptions.len) trails[trailId].shift();\n            }\n        }\n        function generateTrailsGeoJSON(data) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.length; i++){\n                var row = data[i];\n                geojson.features.push({\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"LineString\",\n                        coordinates: trails[getTrailId(row)]\n                    }\n                });\n            }\n            return geojson;\n        }\n        function generateLabelGeoJSON(data) {\n            var geojson = {\n                type: \"FeatureCollection\",\n                features: []\n            };\n            for(var i = 0; i < data.features.length; i++){\n                var feature = data.features[i];\n                var coordinates = void 0;\n                // use center for now\n                var bounds = new library.LngLatBounds();\n                extendBounds(bounds, feature.geometry);\n                if (!bounds.isEmpty()) {\n                    var center = bounds.getCenter();\n                    coordinates = [\n                        center.lng,\n                        center.lat\n                    ];\n                }\n                if (coordinates) geojson.features.push({\n                    type: \"Feature\",\n                    id: i,\n                    geometry: {\n                        type: \"Point\",\n                        coordinates: coordinates\n                    },\n                    properties: feature.properties\n                });\n            }\n            return geojson;\n        }\n        function layerBeforeFill(map) {\n            // place below labels\n            var layers = map.getStyle().layers;\n            var beforeId;\n            for(var i = layers.length - 1; i >= 0; i--){\n                var layer = layers[i];\n                // TODO improve\n                if (!(layer.metadata && layer.metadata[\"mapbox:featureComponent\"] === \"place-labels\")) break;\n                beforeId = layer.id;\n            }\n            return beforeId;\n        }\n        function addLayer(name, geojson) {\n            var centersById = {};\n            map.addSource(name, {\n                type: \"geojson\",\n                data: geojson\n            });\n            if (mapType === \"point\") {\n                // use a symbol layer for markers for performance\n                // https://docs.mapbox.com/help/getting-started/add-markers/#approach-1-adding-markers-inside-a-map\n                // use separate layers to prevent labels from overlapping markers\n                map.addLayer({\n                    id: name + \"-text\",\n                    source: name,\n                    type: \"symbol\",\n                    layout: {\n                        \"text-field\": \"{label}\",\n                        \"text-size\": 11,\n                        \"text-anchor\": \"top\",\n                        \"text-offset\": [\n                            0,\n                            1\n                        ]\n                    },\n                    paint: {\n                        \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\n                        \"text-halo-width\": 1\n                    }\n                });\n                map.addLayer({\n                    id: name,\n                    source: name,\n                    type: \"symbol\",\n                    layout: {\n                        \"icon-image\": \"{icon}-15\",\n                        \"icon-allow-overlap\": true,\n                        \"icon-size\": {\n                            type: \"identity\",\n                            property: \"mapkickIconSize\"\n                        },\n                        \"icon-anchor\": {\n                            type: \"identity\",\n                            property: \"mapkickIconAnchor\"\n                        },\n                        \"icon-offset\": {\n                            type: \"identity\",\n                            property: \"mapkickIconOffset\"\n                        }\n                    }\n                });\n            } else {\n                var beforeId = layerBeforeFill(map);\n                var outlineId = name + \"-outline\";\n                map.addLayer({\n                    id: outlineId,\n                    source: name,\n                    type: \"line\",\n                    paint: {\n                        \"line-color\": {\n                            type: \"identity\",\n                            property: \"mapkickColor\"\n                        },\n                        \"line-opacity\": 0.7,\n                        \"line-width\": 1\n                    }\n                }, beforeId);\n                map.addLayer({\n                    id: name,\n                    source: name,\n                    type: \"fill\",\n                    paint: {\n                        \"fill-color\": {\n                            type: \"identity\",\n                            property: \"mapkickColor\"\n                        },\n                        \"fill-opacity\": 0.3\n                    }\n                }, outlineId);\n                var labelName = name + \"-text\";\n                var labelData = generateLabelGeoJSON(geojson);\n                for(var i = 0; i < labelData.features.length; i++){\n                    var feature = labelData.features[i];\n                    centersById[feature.id] = feature.geometry.coordinates;\n                }\n                map.addSource(labelName, {\n                    type: \"geojson\",\n                    data: labelData\n                });\n                map.addLayer({\n                    id: name + \"-text\",\n                    source: labelName,\n                    type: \"symbol\",\n                    layout: {\n                        \"text-field\": \"{label}\",\n                        \"text-size\": 11\n                    },\n                    paint: {\n                        \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\n                        \"text-halo-width\": 1\n                    }\n                });\n            }\n            var hover = !(\"hover\" in tooltipOptions) || tooltipOptions.hover;\n            var popupOptions = {\n                closeButton: false,\n                closeOnClick: false\n            };\n            if (!hover) popupOptions.anchor = \"bottom\";\n            // create a popup\n            var popup = new library.Popup(popupOptions);\n            // ensure tooltip is visible\n            var panMap = function(map, popup) {\n                var style = window.getComputedStyle(popup.getElement());\n                var matrix = new DOMMatrixReadOnly(style.transform);\n                var padding = 5;\n                var extra = 5;\n                var top = matrix.m42;\n                var left = matrix.m41;\n                // TODO add right and bottom\n                if (top < padding || left < padding) map.panBy([\n                    Math.min(left - padding - extra, 0),\n                    Math.min(top - padding - extra, 0)\n                ]);\n            };\n            var showPopup = function(e) {\n                var feature = selectedFeature(e);\n                var tooltip = feature.properties.tooltip;\n                if (!tooltip) return;\n                if (mapType === \"point\" && feature.properties.icon.startsWith(\"mapkick-\")) popup.options.offset = {\n                    \"top\": [\n                        0,\n                        14\n                    ],\n                    \"top-left\": [\n                        0,\n                        14\n                    ],\n                    \"top-right\": [\n                        0,\n                        14\n                    ],\n                    \"bottom\": [\n                        0,\n                        -44\n                    ],\n                    \"bottom-left\": [\n                        0,\n                        -44\n                    ],\n                    \"bottom-right\": [\n                        0,\n                        -44\n                    ],\n                    \"left\": [\n                        14,\n                        0\n                    ],\n                    \"right\": [\n                        -14,\n                        0\n                    ]\n                };\n                else popup.options.offset = 14;\n                var coordinates;\n                if (mapType === \"point\") coordinates = feature.geometry.coordinates;\n                else coordinates = centersById[feature.id];\n                // add the tooltip\n                popup.setLngLat(coordinates);\n                if (tooltipOptions.html) popup.setHTML(tooltip);\n                else popup.setText(tooltip);\n                popup.addTo(map);\n                // fix blurriness for non-retina screens\n                // https://github.com/mapbox/mapbox-gl-js/pull/3258\n                if (popup._container.offsetWidth % 2 !== 0) popup._container.style.width = popup._container.offsetWidth + 1 + \"px\";\n                if (mapType !== \"area\") panMap(map, popup);\n            };\n            var getLatitude = function(feature) {\n                return feature.geometry.coordinates[1];\n            };\n            var selectedFeature = function(e) {\n                var features = e.features;\n                var selected = features[0];\n                for(var i = 1; i < features.length; i++){\n                    var feature = features[i];\n                    // no need to handle ties since this is stable\n                    if (getLatitude(feature) < getLatitude(selected)) selected = feature;\n                }\n                return selected;\n            };\n            if (!hover) {\n                var currentPoint = null;\n                map.on(\"click\", name, function(e) {\n                    var point = selectedFeature(e).id;\n                    if (point !== currentPoint) {\n                        showPopup(e);\n                        currentPoint = point;\n                        e.mapkickPopupOpened = true;\n                    }\n                });\n                map.on(\"click\", function(e) {\n                    if (!e.mapkickPopupOpened) {\n                        popup.remove();\n                        currentPoint = null;\n                    }\n                });\n            }\n            map.on(\"mouseenter\", name, function(e) {\n                var tooltip = selectedFeature(e).properties.tooltip;\n                if (tooltip) {\n                    map.getCanvas().style.cursor = \"pointer\";\n                    if (hover) showPopup(e);\n                }\n            });\n            map.on(\"mouseleave\", name, function() {\n                map.getCanvas().style.cursor = \"\";\n                if (hover) popup.remove();\n            });\n        }\n        function extendBounds(bounds, geometry) {\n            if (geometry.type === \"Point\") bounds.extend(geometry.coordinates);\n            else if (geometry.type === \"Polygon\") {\n                var coordinates = geometry.coordinates[0];\n                for(var j = 0; j < coordinates.length; j++)bounds.extend(coordinates[j]);\n            } else if (geometry.type === \"MultiPolygon\") {\n                var coordinates$1 = geometry.coordinates;\n                for(var j$1 = 0; j$1 < coordinates$1.length; j$1++){\n                    var polygon = coordinates$1[j$1][0];\n                    for(var k = 0; k < polygon.length; k++)bounds.extend(polygon[k]);\n                }\n            }\n        }\n        var generateMap = function(element, data, options) {\n            var geojson = generateGeoJSON(data, options);\n            options = options || {};\n            for(var i = 0; i < geojson.features.length; i++)extendBounds(bounds, geojson.features[i].geometry);\n            // remove any child elements\n            element.textContent = \"\";\n            var style = options.style;\n            if (!style) {\n                var isMapLibre = !(\"accessToken\" in library) || /^1\\.1[45]/.test(library.version);\n                if (isMapLibre) throw new Error(\"style required for MapLibre\");\n                else style = \"mapbox://styles/mapbox/streets-v12\";\n            }\n            var zoom = options.zoom;\n            var center = options.center;\n            if (!center) {\n                if (!bounds.isEmpty()) center = bounds.getCenter();\n                else {\n                    center = [\n                        0,\n                        0\n                    ];\n                    if (!zoom) zoom = 1;\n                }\n            }\n            if (!zoom) zoom = 15;\n            var mapOptions = {\n                container: element,\n                style: style,\n                dragRotate: false,\n                touchZoomRotate: false,\n                center: center,\n                zoom: zoom\n            };\n            if (!options.style) mapOptions.projection = \"mercator\";\n            if (options.accessToken) mapOptions.accessToken = options.accessToken;\n            if (options.library) Object.assign(mapOptions, options.library);\n            map = new library.Map(mapOptions);\n            if (options.controls) map.addControl(new library.NavigationControl({\n                showCompass: false\n            }));\n            if (!options.zoom) {\n                // hack to prevent error\n                if (!map.style.stylesheet) map.style.stylesheet = {};\n                // check zoom for hash library option\n                if (!bounds.isEmpty() && map.getZoom() === zoom) map.fitBounds(bounds, {\n                    padding: 40,\n                    animate: false,\n                    maxZoom: 15\n                });\n            }\n            this$1$1.map = map;\n            onMapLoad(function() {\n                if (options.trail) {\n                    recordTrails(data);\n                    map.addSource(\"trails\", {\n                        type: \"geojson\",\n                        data: generateTrailsGeoJSON([])\n                    });\n                    map.addLayer({\n                        id: \"trails\",\n                        source: \"trails\",\n                        type: \"line\",\n                        layout: {\n                            \"line-join\": \"round\",\n                            \"line-cap\": \"round\"\n                        },\n                        paint: {\n                            \"line-color\": \"#888\",\n                            \"line-width\": 2\n                        }\n                    });\n                }\n                var outstanding = markerIds.size;\n                function checkReady() {\n                    if (outstanding !== 0) {\n                        outstanding--;\n                        return;\n                    }\n                    addLayer(\"objects\", geojson);\n                    layersReady = true;\n                    var cb;\n                    while(cb = layersReadyQueue.shift())cb();\n                }\n                // load marker images\n                markerIds.forEach(function(id, color) {\n                    var image = createMarkerImage(library, color);\n                    image.addEventListener(\"load\", function() {\n                        map.addImage(\"mapkick-\" + id + \"-15\", image);\n                        checkReady();\n                    });\n                });\n                checkReady();\n            });\n        };\n        var layersReady = false;\n        var layersReadyQueue = [];\n        function onLayersReady(callback) {\n            if (layersReady) callback();\n            else layersReadyQueue.push(callback);\n        }\n        // main\n        options = options || {};\n        options = Object.assign({}, Mapkick.options, options);\n        var tooltipOptions = options.tooltips || {};\n        var markerOptions = options.markers || {};\n        var bounds = new library.LngLatBounds();\n        if (options.replay) fetchData(element, data, options, generateReplayMap);\n        else {\n            fetchData(element, data, options, generateMap);\n            if (options.refresh) this.intervalId = setInterval(function() {\n                fetchData(element, data, options, updateMap);\n            }, options.refresh * 1000);\n        }\n    };\n    BaseMap.prototype.getMapObject = function getMapObject() {\n        return this.map;\n    };\n    BaseMap.prototype.destroy = function destroy() {\n        this.stopRefresh();\n        if (this.map) {\n            this.map.remove();\n            this.map = null;\n        }\n    };\n    BaseMap.prototype.stopRefresh = function stopRefresh() {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n    };\n    var Map = /*@__PURE__*/ function(BaseMap) {\n        function Map(element, data, options) {\n            BaseMap.call(this, element, data, options, \"point\");\n        }\n        if (BaseMap) Map.__proto__ = BaseMap;\n        Map.prototype = Object.create(BaseMap && BaseMap.prototype);\n        Map.prototype.constructor = Map;\n        return Map;\n    }(BaseMap);\n    var AreaMap = /*@__PURE__*/ function(BaseMap) {\n        function AreaMap(element, data, options) {\n            BaseMap.call(this, element, data, options, \"area\");\n        }\n        if (BaseMap) AreaMap.__proto__ = BaseMap;\n        AreaMap.prototype = Object.create(BaseMap && BaseMap.prototype);\n        AreaMap.prototype.constructor = AreaMap;\n        return AreaMap;\n    }(BaseMap);\n    var Mapkick = {\n        Map: Map,\n        AreaMap: AreaMap,\n        maps: maps,\n        options: {},\n        library: null\n    };\n    Mapkick.use = function(library) {\n        Mapkick.library = library;\n    };\n    // not ideal, but allows for simpler integration\n    if (typeof window !== \"undefined\" && !window.Mapkick) {\n        window.Mapkick = Mapkick;\n        // use setTimeout so mapping library can come later in same JS file\n        setTimeout(function() {\n            window.dispatchEvent(new Event(\"mapkick:load\"));\n        }, 0);\n    }\n    return Mapkick;\n});\n\n//# sourceMappingURL=index.fcadd1a0.js.map\n","/*\r\n * Mapkick.js v0.2.6\r\n * Create beautiful, interactive maps with one line of JavaScript\r\n * https://github.com/ankane/mapkick.js\r\n * MIT License\r\n */\r\n\r\n(function (global, factory) {\r\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n  typeof define === 'function' && define.amd ? define(factory) :\r\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Mapkick = factory());\r\n})(this, (function () { 'use strict';\r\n\r\n  function getElement(element) {\r\n    if (typeof element === \"string\") {\r\n      var elementId = element;\r\n      element = document.getElementById(element);\r\n      if (!element) {\r\n        throw new Error(\"No element with id \" + elementId)\r\n      }\r\n    }\r\n    return element\r\n  }\r\n\r\n  // check for hex or named color\r\n  function validateColor(color) {\r\n    if (!/^#([0-9a-f]{3}){1,2}$/i.test(color) && !/^[a-z]+$/i.test(color)) {\r\n      throw new Error(\"Invalid color\")\r\n    }\r\n  }\r\n\r\n  function createMarkerImage(library, color) {\r\n    // set height to center vertically\r\n    var height = 41;\r\n    var width = 27;\r\n    var scale = 2;\r\n\r\n    // get marker svg\r\n    var svg = (new library.Marker())._element.querySelector(\"svg\");\r\n\r\n    // make displayable and center vertically\r\n    svg.removeAttribute(\"display\");\r\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\r\n    svg.setAttribute(\"height\", height);\r\n    svg.setAttribute(\"width\", width);\r\n    svg.setAttribute(\"viewBox\", (\"0 0 \" + width + \" \" + height));\r\n\r\n    validateColor(color);\r\n\r\n    // set color\r\n    svg.querySelector(\"*[fill='#3FB1CE']\").setAttribute(\"fill\", color);\r\n\r\n    // add border to inner circle\r\n    var circles = svg.querySelectorAll(\"circle\");\r\n    var circle = circles[circles.length - 1];\r\n    if (circles.length == 1) {\r\n      // need to insert new circle for mapbox-gl v2\r\n      var c = circle.cloneNode();\r\n      c.setAttribute(\"fill\", \"#000000\");\r\n      c.setAttribute(\"opacity\", 0.25);\r\n      circle.parentNode.insertBefore(c, circle);\r\n    }\r\n    circle.setAttribute(\"r\", 4.5);\r\n\r\n    // create image\r\n    var image = new Image(width * scale, height * scale);\r\n    image.src = \"data:image/svg+xml;utf8,\" + (encodeURIComponent(svg.outerHTML));\r\n    return image\r\n  }\r\n\r\n  var maps = {};\r\n\r\n  var BaseMap = function BaseMap(element, data, options, mapType) {\r\n    var this$1$1 = this;\r\n\r\n    if (!Mapkick.library && typeof window !== \"undefined\") {\r\n      Mapkick.library = window.mapboxgl || window.maplibregl || null;\r\n    }\r\n\r\n    var library = Mapkick.library;\r\n    if (!library) {\r\n      throw new Error(\"No mapping library found\")\r\n    }\r\n\r\n    var map;\r\n    var trails = {};\r\n    var groupedData = {};\r\n    var timestamps = [];\r\n    var timeIndex = 0;\r\n\r\n    element = getElement(element);\r\n\r\n    if (element.id) {\r\n      maps[element.id] = this;\r\n    }\r\n\r\n    function getJSON(element, url, success) {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open(\"GET\", url, true);\r\n      xhr.setRequestHeader(\"Content-Type\", \"application/json\");\r\n      xhr.onload = function () {\r\n        if (xhr.status === 200) {\r\n          success(JSON.parse(xhr.responseText));\r\n        } else {\r\n          showError(element, xhr.statusText);\r\n        }\r\n      };\r\n      xhr.send();\r\n    }\r\n\r\n    function onMapLoad(callback) {\r\n      if (map.loaded()) {\r\n        callback();\r\n      } else {\r\n        map.on(\"load\", callback);\r\n      }\r\n    }\r\n\r\n    function toTimestamp(ts) {\r\n      if (typeof ts === \"number\") {\r\n        return ts\r\n      } else {\r\n        return (new Date(ts)).getTime() / 1000\r\n      }\r\n    }\r\n\r\n    function generateReplayMap(element, data, options) {\r\n      // group data\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var ts = toTimestamp(row.time);\r\n        if (ts) {\r\n          if (!groupedData[ts]) {\r\n            groupedData[ts] = [];\r\n          }\r\n          groupedData[ts].push(row);\r\n          bounds.extend(rowCoordinates(row));\r\n        }\r\n      }\r\n\r\n      for (var i$1 in groupedData) {\r\n        if (Object.prototype.hasOwnProperty.call(groupedData, i$1)) {\r\n          timestamps.push(parseInt(i$1));\r\n        }\r\n      }\r\n      timestamps.sort();\r\n\r\n      // create map\r\n      generateMap(element, groupedData[timestamps[timeIndex]], options);\r\n\r\n      onMapLoad(function () {\r\n        setTimeout(function () {\r\n          nextFrame(element, options);\r\n        }, 100);\r\n      });\r\n    }\r\n\r\n    function nextFrame(element, options) {\r\n      timeIndex++;\r\n\r\n      updateMap(element, groupedData[timestamps[timeIndex]], options);\r\n\r\n      if (timeIndex < timestamps.length - 1) {\r\n        setTimeout(function () {\r\n          nextFrame(element, options);\r\n        }, 100);\r\n      }\r\n    }\r\n\r\n    function showError(element, message) {\r\n      element.textContent = message;\r\n    }\r\n\r\n    function errorCatcher(element, data, options, callback) {\r\n      try {\r\n        callback(element, data, options);\r\n      } catch (err) {\r\n        showError(element, err.message);\r\n        throw err\r\n      }\r\n    }\r\n\r\n    function fetchData(element, data, options, callback) {\r\n      if (typeof data === \"string\") {\r\n        getJSON(element, data, function (newData) {\r\n          errorCatcher(element, newData, options, callback);\r\n        });\r\n      } else if (typeof data === \"function\") {\r\n        data(function (newData) {\r\n          errorCatcher(element, newData, options, callback);\r\n        }, function (message) {\r\n          showError(element, message);\r\n        });\r\n      } else {\r\n        errorCatcher(element, data, options, callback);\r\n      }\r\n    }\r\n\r\n    function updateMap(element, data, options) {\r\n      onLayersReady(function () {\r\n        if (options.trail) {\r\n          recordTrails(data, options.trail);\r\n          map.getSource(\"trails\").setData(generateTrailsGeoJSON(data));\r\n        }\r\n        map.getSource(\"objects\").setData(generateGeoJSON(data, options));\r\n      });\r\n    }\r\n\r\n    // use Map instead of object for security\r\n    var markerIds = new window.Map();\r\n\r\n    function generateGeoJSON(data, options) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var properties = Object.assign({}, row);\r\n        var geometry = (void 0);\r\n\r\n        if (mapType === \"point\") {\r\n          if (!properties.icon) {\r\n            properties.icon = options.defaultIcon || \"mapkick\";\r\n          }\r\n          properties.mapkickIconSize = properties.icon === \"mapkick\" ? 0.5 : 1;\r\n          properties.mapkickIconAnchor = properties.icon === \"mapkick\" ? \"bottom\" : \"center\";\r\n          properties.mapkickIconOffset = properties.icon === \"mapkick\" ? [0, 10] : [0, 0];\r\n\r\n          if (properties.icon === \"mapkick\") {\r\n            var color = properties.color || markerOptions.color || \"#f84d4d\";\r\n\r\n            var markerId = markerIds.get(color);\r\n            if (markerId === undefined) {\r\n              markerId = markerIds.size;\r\n              validateColor(color);\r\n              markerIds.set(color, markerId);\r\n            }\r\n\r\n            properties.icon = \"mapkick-\" + markerId;\r\n          }\r\n\r\n          var coordinates = rowCoordinates(row);\r\n\r\n          if (!coordinates[1]) {\r\n            throw new Error((\"missing latitude (index: \" + i + \")\"))\r\n          }\r\n\r\n          if (!coordinates[0]) {\r\n            throw new Error((\"missing longitude (index: \" + i + \")\"))\r\n          }\r\n\r\n          geometry = {\r\n            type: \"Point\",\r\n            coordinates: coordinates\r\n          };\r\n        } else {\r\n          geometry = row.geometry;\r\n\r\n          if (!geometry) {\r\n            throw new Error((\"missing geometry (index: \" + i + \")\"))\r\n          }\r\n\r\n          delete properties.geometry;\r\n\r\n          properties.mapkickColor = properties.color || markerOptions.color || \"#0090ff\";\r\n\r\n        }\r\n\r\n        geojson.features.push({\r\n          type: \"Feature\",\r\n          id: i,\r\n          geometry: geometry,\r\n          properties: properties\r\n        });\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function rowCoordinates(row) {\r\n      return [row.longitude || row.lng || row.lon, row.latitude || row.lat]\r\n    }\r\n\r\n    function getTrailId(row) {\r\n      return row.id\r\n    }\r\n\r\n    function recordTrails(data, trailOptions) {\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        var trailId = getTrailId(row);\r\n        if (!trails[trailId]) {\r\n          trails[trailId] = [];\r\n        }\r\n        trails[trailId].push(rowCoordinates(row));\r\n        if (trailOptions && trailOptions.len && trails[trailId].length > trailOptions.len) {\r\n          trails[trailId].shift();\r\n        }\r\n      }\r\n    }\r\n\r\n    function generateTrailsGeoJSON(data) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.length; i++) {\r\n        var row = data[i];\r\n        geojson.features.push({\r\n          type: \"Feature\",\r\n          geometry: {\r\n            type: \"LineString\",\r\n            coordinates: trails[getTrailId(row)]\r\n          }\r\n        });\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function generateLabelGeoJSON(data) {\r\n      var geojson = {\r\n        type: \"FeatureCollection\",\r\n        features: []\r\n      };\r\n\r\n      for (var i = 0; i < data.features.length; i++) {\r\n        var feature = data.features[i];\r\n        var coordinates = (void 0);\r\n\r\n        // use center for now\r\n        var bounds = new library.LngLatBounds();\r\n        extendBounds(bounds, feature.geometry);\r\n        if (!bounds.isEmpty()) {\r\n          var center = bounds.getCenter();\r\n          coordinates = [center.lng, center.lat];\r\n        }\r\n\r\n        if (coordinates) {\r\n          geojson.features.push({\r\n            type: \"Feature\",\r\n            id: i,\r\n            geometry: {\r\n              type: \"Point\",\r\n              coordinates: coordinates\r\n            },\r\n            properties: feature.properties\r\n          });\r\n        }\r\n      }\r\n\r\n      return geojson\r\n    }\r\n\r\n    function layerBeforeFill(map) {\r\n      // place below labels\r\n      var layers = map.getStyle().layers;\r\n      var beforeId;\r\n      for (var i = layers.length - 1; i >= 0; i--) {\r\n        var layer = layers[i];\r\n        // TODO improve\r\n        if (!(layer.metadata && layer.metadata[\"mapbox:featureComponent\"] === \"place-labels\")) {\r\n          break\r\n        }\r\n        beforeId = layer.id;\r\n      }\r\n      return beforeId\r\n    }\r\n\r\n    function addLayer(name, geojson) {\r\n      var centersById = {};\r\n\r\n      map.addSource(name, {\r\n        type: \"geojson\",\r\n        data: geojson\r\n      });\r\n\r\n      if (mapType === \"point\") {\r\n        // use a symbol layer for markers for performance\r\n        // https://docs.mapbox.com/help/getting-started/add-markers/#approach-1-adding-markers-inside-a-map\r\n        // use separate layers to prevent labels from overlapping markers\r\n        map.addLayer({\r\n          id: (name + \"-text\"),\r\n          source: name,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"text-field\": \"{label}\",\r\n            \"text-size\": 11,\r\n            \"text-anchor\": \"top\",\r\n            \"text-offset\": [0, 1]\r\n          },\r\n          paint: {\r\n            \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\r\n            \"text-halo-width\": 1\r\n          }\r\n        });\r\n        map.addLayer({\r\n          id: name,\r\n          source: name,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"icon-image\": \"{icon}-15\",\r\n            \"icon-allow-overlap\": true,\r\n            \"icon-size\": {type: \"identity\", property: \"mapkickIconSize\"},\r\n            \"icon-anchor\": {type: \"identity\", property: \"mapkickIconAnchor\"},\r\n            \"icon-offset\": {type: \"identity\", property: \"mapkickIconOffset\"}\r\n          }\r\n        });\r\n      } else {\r\n        var beforeId = layerBeforeFill(map);\r\n\r\n        var outlineId = name + \"-outline\";\r\n        map.addLayer({\r\n          id: outlineId,\r\n          source: name,\r\n          type: \"line\",\r\n          paint: {\r\n            \"line-color\": {type: \"identity\", property: \"mapkickColor\"},\r\n            \"line-opacity\": 0.7,\r\n            \"line-width\": 1\r\n          }\r\n        }, beforeId);\r\n\r\n        map.addLayer({\r\n          id: name,\r\n          source: name,\r\n          type: \"fill\",\r\n          paint: {\r\n            \"fill-color\": {type: \"identity\", property: \"mapkickColor\"},\r\n            \"fill-opacity\": 0.3\r\n          }\r\n        }, outlineId);\r\n\r\n        var labelName = name + \"-text\";\r\n        var labelData = generateLabelGeoJSON(geojson);\r\n\r\n        for (var i = 0; i < labelData.features.length; i++) {\r\n          var feature = labelData.features[i];\r\n          centersById[feature.id] = feature.geometry.coordinates;\r\n        }\r\n\r\n        map.addSource(labelName, {\r\n          type: \"geojson\",\r\n          data: labelData\r\n        });\r\n\r\n        map.addLayer({\r\n          id: (name + \"-text\"),\r\n          source: labelName,\r\n          type: \"symbol\",\r\n          layout: {\r\n            \"text-field\": \"{label}\",\r\n            \"text-size\": 11\r\n          },\r\n          paint: {\r\n            \"text-halo-color\": \"rgba(255, 255, 255, 1)\",\r\n            \"text-halo-width\": 1\r\n          }\r\n        });\r\n      }\r\n\r\n      var hover = !(\"hover\" in tooltipOptions) || tooltipOptions.hover;\r\n\r\n      var popupOptions = {\r\n        closeButton: false,\r\n        closeOnClick: false\r\n      };\r\n      if (!hover) {\r\n        popupOptions.anchor = \"bottom\";\r\n      }\r\n\r\n      // create a popup\r\n      var popup = new library.Popup(popupOptions);\r\n\r\n      // ensure tooltip is visible\r\n      var panMap = function (map, popup) {\r\n        var style = window.getComputedStyle(popup.getElement());\r\n        var matrix = new DOMMatrixReadOnly(style.transform);\r\n        var padding = 5;\r\n        var extra = 5;\r\n        var top = matrix.m42;\r\n        var left = matrix.m41;\r\n\r\n        // TODO add right and bottom\r\n        if (top < padding || left < padding) {\r\n          map.panBy([Math.min(left - padding - extra, 0), Math.min(top - padding - extra, 0)]);\r\n        }\r\n      };\r\n\r\n      var showPopup = function (e) {\r\n        var feature = selectedFeature(e);\r\n        var tooltip = feature.properties.tooltip;\r\n\r\n        if (!tooltip) {\r\n          return\r\n        }\r\n\r\n        if (mapType === \"point\" && feature.properties.icon.startsWith(\"mapkick-\")) {\r\n          popup.options.offset = {\r\n            \"top\": [0, 14],\r\n            \"top-left\": [0, 14],\r\n            \"top-right\": [0, 14],\r\n            \"bottom\": [0, -44],\r\n            \"bottom-left\": [0, -44],\r\n            \"bottom-right\": [0, -44],\r\n            \"left\": [14, 0],\r\n            \"right\": [-14, 0]\r\n          };\r\n        } else {\r\n          popup.options.offset = 14;\r\n        }\r\n\r\n        var coordinates;\r\n        if (mapType === \"point\") {\r\n          coordinates = feature.geometry.coordinates;\r\n        } else {\r\n          coordinates = centersById[feature.id];\r\n        }\r\n\r\n        // add the tooltip\r\n        popup.setLngLat(coordinates);\r\n        if (tooltipOptions.html) {\r\n          popup.setHTML(tooltip);\r\n        } else {\r\n          popup.setText(tooltip);\r\n        }\r\n        popup.addTo(map);\r\n\r\n        // fix blurriness for non-retina screens\r\n        // https://github.com/mapbox/mapbox-gl-js/pull/3258\r\n        if (popup._container.offsetWidth % 2 !== 0) {\r\n          popup._container.style.width = popup._container.offsetWidth + 1 + \"px\";\r\n        }\r\n\r\n        if (mapType !== \"area\") {\r\n          panMap(map, popup);\r\n        }\r\n      };\r\n\r\n      var getLatitude = function (feature) {\r\n        return feature.geometry.coordinates[1]\r\n      };\r\n\r\n      var selectedFeature = function (e) {\r\n        var features = e.features;\r\n        var selected = features[0];\r\n        for (var i = 1; i < features.length; i++) {\r\n          var feature = features[i];\r\n          // no need to handle ties since this is stable\r\n          if (getLatitude(feature) < getLatitude(selected)) {\r\n            selected = feature;\r\n          }\r\n        }\r\n        return selected\r\n      };\r\n\r\n      if (!hover) {\r\n        var currentPoint = null;\r\n\r\n        map.on(\"click\", name, function (e) {\r\n          var point = selectedFeature(e).id;\r\n          if (point !== currentPoint) {\r\n            showPopup(e);\r\n            currentPoint = point;\r\n            e.mapkickPopupOpened = true;\r\n          }\r\n        });\r\n\r\n        map.on(\"click\", function (e) {\r\n          if (!e.mapkickPopupOpened) {\r\n            popup.remove();\r\n            currentPoint = null;\r\n          }\r\n        });\r\n      }\r\n\r\n      map.on(\"mouseenter\", name, function (e) {\r\n        var tooltip = selectedFeature(e).properties.tooltip;\r\n\r\n        if (tooltip) {\r\n          map.getCanvas().style.cursor = \"pointer\";\r\n\r\n          if (hover) {\r\n            showPopup(e);\r\n          }\r\n        }\r\n      });\r\n\r\n      map.on(\"mouseleave\", name, function () {\r\n        map.getCanvas().style.cursor = \"\";\r\n\r\n        if (hover) {\r\n          popup.remove();\r\n        }\r\n      });\r\n    }\r\n\r\n    function extendBounds(bounds, geometry) {\r\n      if (geometry.type === \"Point\") {\r\n        bounds.extend(geometry.coordinates);\r\n      } else if (geometry.type === \"Polygon\") {\r\n        var coordinates = geometry.coordinates[0];\r\n        for (var j = 0; j < coordinates.length; j++) {\r\n          bounds.extend(coordinates[j]);\r\n        }\r\n      } else if (geometry.type === \"MultiPolygon\") {\r\n        var coordinates$1 = geometry.coordinates;\r\n        for (var j$1 = 0; j$1 < coordinates$1.length; j$1++) {\r\n          var polygon = coordinates$1[j$1][0];\r\n          for (var k = 0; k < polygon.length; k++) {\r\n            bounds.extend(polygon[k]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    var generateMap = function (element, data, options) {\r\n      var geojson = generateGeoJSON(data, options);\r\n      options = options || {};\r\n\r\n      for (var i = 0; i < geojson.features.length; i++) {\r\n        extendBounds(bounds, geojson.features[i].geometry);\r\n      }\r\n\r\n      // remove any child elements\r\n      element.textContent = \"\";\r\n\r\n      var style = options.style;\r\n      if (!style) {\r\n        var isMapLibre = !(\"accessToken\" in library) || /^1\\.1[45]/.test(library.version);\r\n        if (isMapLibre) {\r\n          throw new Error(\"style required for MapLibre\")\r\n        } else {\r\n          style = \"mapbox://styles/mapbox/streets-v12\";\r\n        }\r\n      }\r\n\r\n      var zoom = options.zoom;\r\n      var center = options.center;\r\n      if (!center) {\r\n        if (!bounds.isEmpty()) {\r\n          center = bounds.getCenter();\r\n        } else {\r\n          center = [0, 0];\r\n          if (!zoom) {\r\n            zoom = 1;\r\n          }\r\n        }\r\n      }\r\n      if (!zoom) {\r\n        zoom = 15;\r\n      }\r\n\r\n      var mapOptions = {\r\n        container: element,\r\n        style: style,\r\n        dragRotate: false,\r\n        touchZoomRotate: false,\r\n        center: center,\r\n        zoom: zoom\r\n      };\r\n      if (!options.style) {\r\n        mapOptions.projection = \"mercator\";\r\n      }\r\n      if (options.accessToken) {\r\n        mapOptions.accessToken = options.accessToken;\r\n      }\r\n      if (options.library) {\r\n        Object.assign(mapOptions, options.library);\r\n      }\r\n      map = new library.Map(mapOptions);\r\n\r\n      if (options.controls) {\r\n        map.addControl(new library.NavigationControl({showCompass: false}));\r\n      }\r\n\r\n      if (!options.zoom) {\r\n        // hack to prevent error\r\n        if (!map.style.stylesheet) {\r\n          map.style.stylesheet = {};\r\n        }\r\n\r\n        // check zoom for hash library option\r\n        if (!bounds.isEmpty() && map.getZoom() === zoom) {\r\n          map.fitBounds(bounds, {padding: 40, animate: false, maxZoom: 15});\r\n        }\r\n      }\r\n\r\n      this$1$1.map = map;\r\n\r\n      onMapLoad(function () {\r\n        if (options.trail) {\r\n          recordTrails(data);\r\n\r\n          map.addSource(\"trails\", {\r\n            type: \"geojson\",\r\n            data: generateTrailsGeoJSON([])\r\n          });\r\n\r\n          map.addLayer({\r\n            id: \"trails\",\r\n            source: \"trails\",\r\n            type: \"line\",\r\n            layout: {\r\n              \"line-join\": \"round\",\r\n              \"line-cap\": \"round\"\r\n            },\r\n            paint: {\r\n              \"line-color\": \"#888\",\r\n              \"line-width\": 2\r\n            }\r\n          });\r\n        }\r\n\r\n        var outstanding = markerIds.size;\r\n\r\n        function checkReady() {\r\n          if (outstanding !== 0) {\r\n            outstanding--;\r\n            return\r\n          }\r\n\r\n          addLayer(\"objects\", geojson);\r\n\r\n          layersReady = true;\r\n          var cb;\r\n          while ((cb = layersReadyQueue.shift())) {\r\n            cb();\r\n          }\r\n        }\r\n\r\n        // load marker images\r\n        markerIds.forEach(function (id, color) {\r\n          var image = createMarkerImage(library, color);\r\n          image.addEventListener(\"load\", function () {\r\n            map.addImage((\"mapkick-\" + id + \"-15\"), image);\r\n            checkReady();\r\n          });\r\n        });\r\n\r\n        checkReady();\r\n      });\r\n    };\r\n\r\n    var layersReady = false;\r\n    var layersReadyQueue = [];\r\n    function onLayersReady(callback) {\r\n      if (layersReady) {\r\n        callback();\r\n      } else {\r\n        layersReadyQueue.push(callback);\r\n      }\r\n    }\r\n\r\n    // main\r\n\r\n    options = options || {};\r\n    options = Object.assign({}, Mapkick.options, options);\r\n    var tooltipOptions = options.tooltips || {};\r\n    var markerOptions = options.markers || {};\r\n    var bounds = new library.LngLatBounds();\r\n\r\n    if (options.replay) {\r\n      fetchData(element, data, options, generateReplayMap);\r\n    } else {\r\n      fetchData(element, data, options, generateMap);\r\n\r\n      if (options.refresh) {\r\n        this.intervalId = setInterval(function () {\r\n          fetchData(element, data, options, updateMap);\r\n        }, options.refresh * 1000);\r\n      }\r\n    }\r\n  };\r\n\r\n  BaseMap.prototype.getMapObject = function getMapObject () {\r\n    return this.map\r\n  };\r\n\r\n  BaseMap.prototype.destroy = function destroy () {\r\n    this.stopRefresh();\r\n\r\n    if (this.map) {\r\n      this.map.remove();\r\n      this.map = null;\r\n    }\r\n  };\r\n\r\n  BaseMap.prototype.stopRefresh = function stopRefresh () {\r\n    if (this.intervalId) {\r\n      clearInterval(this.intervalId);\r\n      this.intervalId = null;\r\n    }\r\n  };\r\n\r\n  var Map = /*@__PURE__*/(function (BaseMap) {\r\n    function Map(element, data, options) {\r\n      BaseMap.call(this, element, data, options, \"point\");\r\n    }\r\n\r\n    if ( BaseMap ) Map.__proto__ = BaseMap;\r\n    Map.prototype = Object.create( BaseMap && BaseMap.prototype );\r\n    Map.prototype.constructor = Map;\r\n\r\n    return Map;\r\n  }(BaseMap));\r\n\r\n  var AreaMap = /*@__PURE__*/(function (BaseMap) {\r\n    function AreaMap(element, data, options) {\r\n      BaseMap.call(this, element, data, options, \"area\");\r\n    }\r\n\r\n    if ( BaseMap ) AreaMap.__proto__ = BaseMap;\r\n    AreaMap.prototype = Object.create( BaseMap && BaseMap.prototype );\r\n    AreaMap.prototype.constructor = AreaMap;\r\n\r\n    return AreaMap;\r\n  }(BaseMap));\r\n\r\n  var Mapkick = {\r\n    Map: Map,\r\n    AreaMap: AreaMap,\r\n    maps: maps,\r\n    options: {},\r\n    library: null\r\n  };\r\n\r\n  Mapkick.use = function (library) {\r\n    Mapkick.library = library;\r\n  };\r\n\r\n  // not ideal, but allows for simpler integration\r\n  if (typeof window !== \"undefined\" && !window.Mapkick) {\r\n    window.Mapkick = Mapkick;\r\n\r\n    // use setTimeout so mapping library can come later in same JS file\r\n    setTimeout(function () {\r\n      window.dispatchEvent(new Event(\"mapkick:load\"));\r\n    }, 0);\r\n  }\r\n\r\n  return Mapkick;\r\n\r\n}));"],"names":["global","factory","validateColor","color","test","Error","maps","BaseMap","element","data","options","mapType","map","this$1$1","Mapkick","library","window","mapboxgl","maplibregl","trails","groupedData","timestamps","timeIndex","onMapLoad","callback","loaded","on","showError","message","textContent","errorCatcher","err","fetchData","getJSON","success","xhr","newData","XMLHttpRequest","open","setRequestHeader","onload","status","JSON","parse","responseText","statusText","send","updateMap","trail","recordTrails","getSource","setData","generateTrailsGeoJSON","generateGeoJSON","layersReady","layersReadyQueue","push","getElement","elementId","document","getElementById","id","markerIds","Map","geojson","type","features","i","length","row","properties","Object","assign","geometry","icon","defaultIcon","mapkickIconSize","mapkickIconAnchor","mapkickIconOffset","markerOptions","markerId","get","undefined","size","set","coordinates","rowCoordinates","mapkickColor","longitude","lng","lon","latitude","lat","trailOptions","trailId","len","shift","extendBounds","bounds","extend","j","coordinates$1","j$1","polygon","k","generateMap","style","version","zoom","center","isEmpty","getCenter","mapOptions","container","dragRotate","touchZoomRotate","projection","accessToken","controls","addControl","NavigationControl","showCompass","stylesheet","getZoom","fitBounds","padding","animate","maxZoom","addSource","addLayer","source","layout","paint","outstanding","checkReady","cb","name","centersById","property","beforeId","layerBeforeFill","layers","getStyle","layer","metadata","outlineId","labelName","labelData","generateLabelGeoJSON","feature","LngLatBounds","hover","tooltipOptions","popupOptions","closeButton","closeOnClick","anchor","popup","Popup","panMap","matrix","DOMMatrixReadOnly","getComputedStyle","transform","top","m42","left","m41","panBy","Math","min","showPopup","e","selectedFeature","tooltip","startsWith","offset","setLngLat","html","setHTML","setText","addTo","_container","offsetWidth","width","getLatitude","selected","currentPoint","point","mapkickPopupOpened","remove","getCanvas","cursor","forEach","image","createMarkerImage","svg","Marker","_element","querySelector","removeAttribute","setAttribute","circles","querySelectorAll","circle","c","cloneNode","parentNode","insertBefore","Image","height","src","encodeURIComponent","outerHTML","addEventListener","addImage","tooltips","markers","replay","ts","time","Date","getTime","i$1","prototype","hasOwnProperty","call","parseInt","sort","setTimeout","nextFrame","refresh","intervalId","setInterval","getMapObject","destroy","stopRefresh","clearInterval","__proto__","create","constructor","AreaMap","use","dispatchEvent","Event","exports","module","define","amd","globalThis","self"],"version":3,"file":"index.fcadd1a0.js.map"}